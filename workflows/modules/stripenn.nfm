nextflow.enable.dsl=2

workflow run_stripenn {
    take:
        cool
        resolution
        chrom

    main:
        run_stripenn_compute(cool, resolution, chrom)

    emit:
        stripenn_filtered=run_stripenn_compute.out.filtered
        stripenn_unfiltered=run_stripenn_compute.out.unfiltered
        stripenn_stripenn=run_stripenn_compute.out.log
}


process run_stripenn_compute {
    publishDir "${params.stripenn_output_prefix}", mode: 'copy'
    
    label 'process_high'
    label 'process_long'
    
    input:
        path cool
        val resolution
        val chroms

    output:
        path "*_filtered.tsv", emit: filtered
        path "*_unfiltered.tsv", emit: unfiltered
        path "*_stripenn.log", emit: log

    shell:
        '''
        input_name="!{cool}"
        if [[ $input_name == *.mcool ]]; then
            input_name="${input_name}::/resolutions/!{resolution}"
        fi    

        # Apparently --norm and --chrom are required in order to get stripenn
        # to work reliably
        stripenn compute --cool "$input_name"   \
                         --out tmpout/          \
                         --chrom "!{chroms}"    \
                         --norm weight          \
                         --numcores !{task.cpus}

        out_prefix="$(basename "!{cool}")"
        out_prefix="${out_prefix%.*}"

        mv tmpout/result_filtered.tsv "${out_prefix}_filtered.tsv"
        mv tmpout/result_unfiltered.tsv "${out_prefix}_unfiltered.tsv"
        mv tmpout/stripenn.log "${out_prefix}_stripenn.log"
        '''
}
